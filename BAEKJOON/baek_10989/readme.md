알고리즘 해석
============


[이 문제의 링크✈](https://www.acmicpc.net/problem/10989)




## 문제 해결에 필요한 알고리즘

Counting Sort

[카운팅 정렬에 대해 잘 정리해놓은 글](https://yaboong.github.io/algorithms/2018/03/20/counting-sort/)





## 문제 해결 후 얻은 Insight


### 1. 메모리 낭비 문제
처음 이 문제를 풀때는 알고리즘에 대한 설명만 읽고 알고리즘의 순서대로 모든것을 구현해보려고 했다. -> CountingSort.java     
코드 자체는 정상적으로 구동이 되었으나, 백준에 올려보니 메모리 초과로 실패해버렸다. 처음으로 직면한 메모리 초과문제.    아래는 그 원인들이다. 

* ArrayList를 생성할때 초기 길이를 지정해주지 않음
처음 생성시 크기를 지정하지 않으면 자바는 자동으로 10의 크기를 가지는 ArrayList를 생성한다. 이 ArrayList에 10개 이상의 값을 넣으려고 하면 자바는 ArrayList의 크기를 2배로 키우고 메모리 재할당을 한다. (10>20>40>80>160>320...)    
이 때문에 매우 많은 값을 ArrayList에 넣으려고 하면 메모리 사용량이 기하급수적으로 늘어나게 된다. ArrayList에 들어갈 값의 크기를 알수있다면 ArrayList 생성시 반드시 크기를 정해줄것.

* add 메소드
위의 문제점을 파악하고 초기 크기를 지정해주었지만 여전히 메모리 초과는 발생. 문제점은 for 문을 통해 ArrayList들의 값을 0으로 초기화하는 과정에서 발생했다.   
ArrayList 에는 배열의 fill 메소드가 없어 일괄적으로 일정값을(이번의 경우 0) 넣는것이 안되는것으로 알고있다. 이 문제점을 파악하고나니 ArrayList로는 메모리 문제를 해결할 수 없을 것이라는데 생각이 미쳤다.    


## 답은? 처음부터 다시.

### 2. 문제의 조건을 잘 읽자
다시 코딩을 하면서 미처 생각하지 못했던 조건이 보였다. 입력받는 자연수의 범위가 최대 10000까지 였던 것이다. 이렇게 되면 처음 배열을 만들때 

    int[] c =new int[10001];// 문제의 조건에 달려있는 수의 최댓값 10000을 담을수 있는 array
  
이렇게 만들면 메모리를 훨씬 더 절약할 수 있다. 10000 이 아니라 10001인 이유는 다음과 같다. 이 배열은 리스트에 존재하는 1부터 10000까지의 숫자들의 중복횟수를 저장해둔 것이다.   
즉, 이 배열의 index값은 곧 각 자연수들이고, 배열의 내용물은 자연수들의 등장횟수이다. 배열은 0부터 시작하므로 int[10001]에 저장 가능한 최대 자연수는 10000이다. 

### 3. 애초에 다 구현할 필요도 없었어...
잘 생각해보면 이 문제는 정렬된 상태의 배열을 출력하는 것이 목표가 아니다. 다만 자연수들을 정렬된 순서대로 출력만 하면 되는것!     따라서 안정정렬을 보장할 필요도 없다. 
애초에 입력배열도 만들필요없이 각 자연수의 갯수를 카운팅해주는 배열만 만들고 순서대로 출력만 하면 되는거였던거임... 덕분에 코드는 훨씬더 간결해졌다. 
알고리즘을 이해하기위해서라면 배열을 전부 만들어내는것도 좋지만 이러한 간단한 해결책도 항상 염두하며 코딩공부를 해야겠다. 


